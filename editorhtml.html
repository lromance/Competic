<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor HTML Pro con Sincronización Visual</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* Estilos personalizados para el scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1e293b; 
        }
        ::-webkit-scrollbar-thumb {
            background: #475569; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b; 
        }

        /* Editor Styles specific */
        .editor-container {
            font-family: 'Fira Code', 'Courier New', monospace;
            line-height: 1.5;
            font-size: 14px;
            position: relative; /* Necesario para contexto */
        }
        
        #line-numbers {
            font-family: 'Fira Code', 'Courier New', monospace;
            line-height: 1.5;
            font-size: 14px;
            text-align: right;
            color: #64748b;
            padding: 10px 10px 10px 0; /* Padding ajustado */
            user-select: none;
            box-sizing: border-box;
            width: 45px; /* Ancho fijo para estabilidad */
        }

        textarea#code-input {
            font-family: 'Fira Code', 'Courier New', monospace;
            line-height: 1.5;
            font-size: 14px;
            
            /* --- CAMBIOS PARA WORD WRAP (SALTO DE LÍNEA) --- */
            white-space: pre-wrap;       /* Permite que el texto baje si no cabe */
            word-break: break-word;      /* Rompe palabras largas si es necesario */
            overflow-wrap: break-word;   /* Estándar moderno */
            overflow-x: hidden;          /* Ocultamos scroll horizontal */
            overflow-y: scroll;          /* Scroll vertical siempre visible para evitar saltos de layout */
            
            tab-size: 4;
            outline: none;
            border: none;
            resize: none;
            background: transparent;
            color: #e2e8f0;
            
            /* Padding y Box Sizing cruciales para la medición exacta */
            padding: 10px;
            width: 100%;
            box-sizing: border-box; 
            padding-left: 10px;
        }

        /* Resaltado de selección */
        ::selection {
            background-color: #facc15; 
            color: #000;
        }

        /* Autocomplete dropdown */
        #autocomplete-list {
            position: absolute;
            background-color: #1e293b;
            border: 1px solid #475569;
            border-radius: 4px;
            z-index: 50;
            max-height: 150px;
            overflow-y: auto;
            display: none;
            width: 200px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
        }
        .suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
            color: #cbd5e1;
        }
        .suggestion-item:hover, .suggestion-item.active {
            background-color: #3b82f6;
            color: white;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-200 h-screen flex flex-col overflow-hidden">

    <!-- Header / Toolbar -->
    <header class="bg-slate-800 border-b border-slate-700 p-3 flex justify-between items-center shadow-md z-10">
        <div class="flex items-center gap-3">
            <i class="fa-solid fa-code text-blue-500 text-xl"></i>
            <h1 class="font-bold text-lg tracking-wide text-blue-100">DevHTML <span class="text-xs font-normal text-slate-400">Editor</span></h1>
        </div>
        
        <div class="flex gap-2">
            <button onclick="document.getElementById('file-input').click()" class="btn-tool" title="Abrir Archivo">
                <i class="fa-solid fa-folder-open"></i>
            </button>
            <input type="file" id="file-input" class="hidden" accept=".html,.htm,.txt">

            <button onclick="downloadFile()" class="btn-tool" title="Descargar">
                <i class="fa-solid fa-download"></i>
            </button>
            
            <div class="w-px h-8 bg-slate-600 mx-2"></div>
            
            <button onclick="undo()" class="btn-tool" title="Deshacer (Ctrl+Z)">
                <i class="fa-solid fa-rotate-left"></i>
            </button>
            <button onclick="redo()" class="btn-tool" title="Rehacer (Ctrl+Y)">
                <i class="fa-solid fa-rotate-right"></i>
            </button>

            <div class="w-px h-8 bg-slate-600 mx-2"></div>

            <button onclick="formatCode()" class="btn-tool" title="Formatear Código">
                <i class="fa-solid fa-wand-magic-sparkles"></i>
            </button>
        </div>
    </header>

    <!-- Main Content Split View -->
    <main class="flex-1 flex flex-col md:flex-row overflow-hidden relative">
        
        <!-- Editor Section -->
        <section class="flex-1 flex flex-col border-r border-slate-700 bg-slate-900 relative min-w-[300px]">
            <div class="flex justify-between items-center bg-slate-800 px-4 py-1 text-xs text-slate-400 uppercase tracking-wider font-semibold">
                <span>Código Fuente (Word Wrap Activo)</span>
                <span id="sync-status" class="text-green-500 hidden transition-opacity duration-300"><i class="fa-solid fa-link"></i> Sync</span>
            </div>
            
            <div class="relative flex-1 flex overflow-hidden editor-container">
                <!-- Line Numbers -->
                <div id="line-numbers" class="bg-slate-900 border-r border-slate-800 shrink-0 overflow-hidden">
                    <!-- Numbers injected by JS -->
                </div>
                
                <!-- Code Area -->
                <textarea id="code-input" class="flex-1 bg-transparent outline-none z-10" spellcheck="false" placeholder="<!-- Escribe tu HTML aquí -->"></textarea>
                
                <!-- Autocomplete Container -->
                <div id="autocomplete-list"></div>
            </div>
        </section>

        <!-- Preview Section -->
        <section class="flex-1 flex flex-col bg-white relative min-w-[300px]">
            <div class="flex justify-between items-center bg-slate-200 px-4 py-1 text-xs text-slate-600 uppercase tracking-wider font-semibold border-b border-slate-300">
                <span>Vista Previa Interactiva</span>
                <span class="text-slate-500">Iframe</span>
            </div>
            <iframe id="preview-frame" class="w-full h-full bg-white border-none" sandbox="allow-scripts allow-modals allow-same-origin"></iframe>
        </section>

    </main>

    <!-- Footer -->
    <footer class="bg-slate-800 text-slate-400 text-xs p-2 border-t border-slate-700 flex justify-between">
        <div id="cursor-position">Ln 1, Col 1</div>
        <div>HTML5 • UTF-8 • <span id="node-count">0 Nodos</span></div>
    </footer>

    <!-- Tailwind Helper Styles for Buttons -->
    <style>
        .btn-tool {
            @apply p-2 rounded text-slate-400 hover:text-white hover:bg-slate-700 transition-colors duration-200 w-10 h-10 flex items-center justify-center;
        }
    </style>

    <script>
        // --- Variables Globales ---
        const textarea = document.getElementById('code-input');
        const lineNumbers = document.getElementById('line-numbers');
        const iframe = document.getElementById('preview-frame');
        const cursorPosDisplay = document.getElementById('cursor-position');
        const autocompleteList = document.getElementById('autocomplete-list');
        const nodeCountDisplay = document.getElementById('node-count');
        const syncStatus = document.getElementById('sync-status');

        let historyStack = [];
        let historyIndex = -1;
        const maxHistory = 50;

        // Tags HTML comunes
        const htmlTags = [
            'div', 'span', 'p', 'h1', 'h2', 'h3', 'section', 'article', 'nav', 'header', 'footer',
            'ul', 'ol', 'li', 'a', 'img', 'button', 'input', 'form', 'label', 'table', 'tr', 'td',
            'script', 'style', 'link', 'meta', 'title', 'head', 'body'
        ];

        // --- Inicialización ---
        // Texto con líneas largas para probar el wrap
        const defaultHTML = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Prueba de Salto de Línea</title>
    <style>
        body { font-family: sans-serif; padding: 20px; color: #333; max-width: 800px; margin: 0 auto; }
        h1 { color: #2563eb; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        p { line-height: 1.6; }
        .box { background: #f8fafc; border: 1px solid #e2e8f0; padding: 15px; border-radius: 8px; margin-top: 20px; }
    </style>
</head>
<body>
    <h1>Editor con Word Wrap Inteligente</h1>
    
    <div class="box">
        <p>Esta es una línea de código extremadamente larga que está diseñada específicamente para probar si la funcionalidad de "word wrap" (salto de línea automático) funciona correctamente en el editor de código. Si todo va bien, deberías ver que esta línea se dobla en múltiples renglones en el panel izquierdo, y lo más importante: <strong>el número de línea correspondiente a la izquierda debería tener la altura correcta para abarcar todo este bloque de texto</strong> sin desalinear los números siguientes.</p>
    </div>

    <p>Intenta escribir más texto largo aquí para ver cómo los números se ajustan dinámicamente...</p>
    
    <button onclick="alert('¡El wrap funciona!')">Probar Botón</button>
</body>
</html>`;

        textarea.value = defaultHTML;
        
        // --- Core: Sincronización de Líneas con Wrap ---

        function updateLineNumbers() {
            const text = textarea.value;
            const lines = text.split('\n');
            
            // 1. "Mirror Element": Creamos un clon invisible para medir alturas reales
            let mirror = document.getElementById('code-mirror');
            if (!mirror) {
                mirror = document.createElement('div');
                mirror.id = 'code-mirror';
                document.body.appendChild(mirror);
                
                // Copiar estilos CRÍTICOS del textarea al mirror
                const style = window.getComputedStyle(textarea);
                mirror.style.fontFamily = style.fontFamily;
                mirror.style.fontSize = style.fontSize;
                mirror.style.lineHeight = style.lineHeight;
                mirror.style.padding = style.padding;
                mirror.style.boxSizing = style.boxSizing;
                mirror.style.whiteSpace = 'pre-wrap';      // Mismo comportamiento wrap
                mirror.style.wordBreak = 'break-word';
                mirror.style.overflowWrap = 'break-word';
                mirror.style.position = 'absolute';
                mirror.style.visibility = 'hidden';
                mirror.style.top = '0';
                mirror.style.left = '0';
            }
            
            // Actualizar ancho del mirror para que coincida con el área útil del textarea
            // Usamos clientWidth que excluye el scrollbar, asegurando medición exacta
            mirror.style.width = textarea.clientWidth + 'px';
            mirror.innerHTML = '';
            
            let lineNumbersHTML = '';

            // 2. Medir cada línea
            lines.forEach((line, index) => {
                const div = document.createElement('div');
                // Usamos textContent y un espacio si está vacío para mantener altura mínima
                div.textContent = line || ' '; 
                
                // Estilos para simular comportamiento de texto
                div.style.whiteSpace = 'pre-wrap';
                div.style.wordBreak = 'break-word';
                div.style.overflowWrap = 'break-word';
                
                mirror.appendChild(div);
                
                // Medir la altura calculada por el navegador
                const height = div.offsetHeight;
                
                // Generar el número con esa altura exacta
                lineNumbersHTML += `<div style="height: ${height}px; display: flex; align-items: flex-start; justify-content: flex-end; padding-right: 5px;">${index + 1}</div>`;
            });

            lineNumbers.innerHTML = lineNumbersHTML;
        }
        
        // Recalcular alturas si cambia el tamaño de la ventana (cambia el wrap point)
        window.addEventListener('resize', updateLineNumbers);

        // --- Funciones Editor Estándar ---

        function updateCursorPosition() {
            const text = textarea.value;
            const cursorPos = textarea.selectionStart;
            const lines = text.substr(0, cursorPos).split("\n");
            const currentLine = lines.length;
            const currentCol = lines[lines.length - 1].length + 1;
            cursorPosDisplay.innerText = `Ln ${currentLine}, Col ${currentCol}`;
        }

        function saveHistory() {
            if (historyIndex === -1 || historyStack[historyIndex] !== textarea.value) {
                if (historyIndex < historyStack.length - 1) {
                    historyStack = historyStack.slice(0, historyIndex + 1);
                }
                historyStack.push(textarea.value);
                if (historyStack.length > maxHistory) historyStack.shift();
                else historyIndex++;
            }
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                textarea.value = historyStack[historyIndex];
                updateAll(false);
            }
        }

        function redo() {
            if (historyIndex < historyStack.length - 1) {
                historyIndex++;
                textarea.value = historyStack[historyIndex];
                updateAll(false);
            }
        }

        // --- Sincronización Iframe ---

        function updatePreview() {
            const content = textarea.value;
            const doc = iframe.contentDocument || iframe.contentWindow.document;
            
            const scriptHelper = `
                <script>
                    document.addEventListener('selectionchange', () => {
                        const sel = window.getSelection();
                        if (!sel.rangeCount) return;
                        const text = sel.toString();
                        if (text.length > 1) {
                            window.parent.postMessage({ type: 'syncFromVisual', text: text }, '*');
                        }
                    });

                    window.highlightText = function(text) {
                        if (!text) return;
                        window.getSelection().removeAllRanges();
                        const found = window.find(text, false, false, true, false, true, false);
                        if (found) {
                            const sel = window.getSelection();
                            if (sel.rangeCount > 0) {
                                const range = sel.getRangeAt(0);
                                if (range && range.startContainer.parentElement) {
                                    range.startContainer.parentElement.scrollIntoView({
                                        behavior: "smooth", 
                                        block: "center"
                                    });
                                }
                            }
                        }
                    };
                    document.addEventListener('submit', (e) => e.preventDefault());
                <\/script>
            `;

            let finalContent = content;
            if (content.includes('</body>')) {
                finalContent = content.replace('</body>', scriptHelper + '</body>');
            } else {
                finalContent += scriptHelper;
            }

            doc.open();
            doc.write(finalContent);
            doc.close();

            nodeCountDisplay.innerText = `${doc.querySelectorAll('*').length} Nodos`;
        }

        function updateAll(saveToHistory = true) {
            updateLineNumbers();
            updatePreview();
            if (saveToHistory) saveHistory();
        }

        // --- Event Listeners ---

        function syncEditorToVisual() {
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const selectedText = textarea.value.substring(start, end);

            if (selectedText.length > 0 && selectedText.trim().length > 0) {
                if (iframe.contentWindow && iframe.contentWindow.highlightText) {
                    iframe.contentWindow.highlightText(selectedText);
                    syncStatus.classList.remove('hidden');
                    setTimeout(() => syncStatus.classList.add('hidden'), 1000);
                }
            }
        }

        textarea.addEventListener('mouseup', syncEditorToVisual);
        textarea.addEventListener('keyup', (e) => {
            if (e.shiftKey && (e.key.startsWith('Arrow') || e.key === 'Home' || e.key === 'End')) {
                syncEditorToVisual();
            }
        });

        textarea.addEventListener('scroll', () => {
            lineNumbers.scrollTop = textarea.scrollTop;
        });

        textarea.addEventListener('input', (e) => {
            updateLineNumbers();
            if (this.debounceTimer) clearTimeout(this.debounceTimer);
            this.debounceTimer = setTimeout(() => {
                updatePreview();
                saveHistory();
            }, 500);
            handleAutocomplete(e);
        });

        textarea.addEventListener('keyup', updateCursorPosition);
        textarea.addEventListener('click', updateCursorPosition);
        textarea.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                e.preventDefault();
                document.execCommand('insertText', false, '    ');
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                undo();
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
                e.preventDefault();
                redo();
            }
        });

        // --- Autocompletado ---

        function handleAutocomplete(e) {
            const cursorPos = textarea.selectionStart;
            const text = textarea.value;
            const charBefore = text.substring(cursorPos - 1, cursorPos);
            
            if (charBefore === '<') {
                showSuggestions(cursorPos);
            } else {
                if ([' ', '>'].includes(charBefore)) {
                    autocompleteList.style.display = 'none';
                }
            }
        }

        function showSuggestions(pos) {
            autocompleteList.innerHTML = '';
            htmlTags.forEach(tag => {
                const div = document.createElement('div');
                div.className = 'suggestion-item';
                div.innerText = tag;
                div.onclick = () => insertTag(tag, pos);
                autocompleteList.appendChild(div);
            });
            autocompleteList.style.bottom = '40px'; 
            autocompleteList.style.left = '60px';
            autocompleteList.style.display = 'block';
        }

        function insertTag(tag, pos) {
            const text = textarea.value;
            const before = text.substring(0, pos);
            const after = text.substring(pos);
            const newText = before + tag + '>' + `</${tag}>` + after;
            textarea.value = newText;
            const newCursorPos = pos + tag.length + 1;
            textarea.setSelectionRange(newCursorPos, newCursorPos);
            autocompleteList.style.display = 'none';
            textarea.focus();
            updateAll();
        }

        // --- Sync Visual -> Code ---
        window.addEventListener('message', (event) => {
            if (event.data.type === 'syncFromVisual') {
                findAndSelectInEditor(event.data.text);
            }
        });

        function findAndSelectInEditor(text) {
            if (!text || text.trim() === '') return;
            const code = textarea.value;
            const index = code.indexOf(text); 
            
            if (index !== -1) {
                // 1. Seleccionar texto
                textarea.focus();
                textarea.setSelectionRange(index, index + text.length);
                
                // 2. SCROLL PRECISO USANDO EL MIRROR
                // Como tenemos word-wrap variable, usamos el mirror para medir 
                // exactamente a qué altura de píxel cae el inicio del texto seleccionado.
                const mirror = document.getElementById('code-mirror');
                if (mirror) {
                    // Limpiamos temporalmente el mirror (usado para números de línea) para medir
                    mirror.innerHTML = '';
                    
                    // Recreamos el contenido exacto hasta el punto de selección
                    const textBefore = code.substring(0, index);
                    const preNode = document.createTextNode(textBefore);
                    mirror.appendChild(preNode);
                    
                    // Ponemos un marcador visible/invisible
                    const marker = document.createElement('span');
                    marker.textContent = '|'; // Carácter para asegurar altura de línea
                    mirror.appendChild(marker);
                    
                    // Medimos la altura exacta (offsetTop)
                    const top = marker.offsetTop;
                    
                    // Centramos el scroll: Posición del marcador - Mitad de altura del editor
                    const editorHeight = textarea.clientHeight;
                    textarea.scrollTop = top - (editorHeight / 2);
                    
                    // 3. Restauramos la UI de números de línea inmediatamente
                    updateLineNumbers();
                }
                
                syncStatus.classList.remove('hidden');
                setTimeout(() => syncStatus.classList.add('hidden'), 1000);
            }
        }

        // --- Utilidades ---

        function formatCode() {
            let xml = textarea.value;
            let formatted = '';
            let reg = /(>)(<)(\/*)/g;
            xml = xml.replace(reg, '$1\r\n$2$3');
            let pad = 0;
            const nodes = xml.split('\r\n');
            for(let i = 0; i < nodes.length; i++) {
                let node = nodes[i];
                let indent = 0;
                if (node.match( /.+<\/\w[^>]*>$/ )) indent = 0;
                else if (node.match( /^<\/\w/ )) { if (pad != 0) pad -= 1; }
                else if (node.match( /^<\w[^>]*[^\/]>.*$/ )) indent = 1;
                else indent = 0;
                let padding = '';
                for (let j = 0; j < pad; j++) padding += '    ';
                formatted += padding + node + '\r\n';
                pad += indent;
            }
            textarea.value = formatted.trim();
            updateAll();
        }

        function downloadFile() {
            const blob = new Blob([textarea.value], {type: "text/html"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = "index.html";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        document.getElementById('file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                textarea.value = e.target.result;
                updateAll();
            };
            reader.readAsText(file);
        });

        // Inicio
        saveHistory();
        updateAll(false);

    </script>
</body>
</html>
